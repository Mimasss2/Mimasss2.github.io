<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git cheatsheet</title>
    <link href="/2022/12/09/git_cheatsheet/"/>
    <url>/2022/12/09/git_cheatsheet/</url>
    
    <content type="html"><![CDATA[<p>A git command cheatsheet.</p><p><span id="more"></span></p><h4 id="create-repo">1 create repo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cli">git init<br></code></pre></td></tr></table></figure><p>初始化当前目录为git仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cli">git clone &lt;url&gt; <br>git clone &lt;url&gt; &lt;dir&gt; # 将仓库克隆到指定的目录<br></code></pre></td></tr></table></figure><p>从<code>url</code>克隆仓库</p><h4 id="modify-and-commit">2 modify and commit</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cli">git add &lt;filename&gt; # 添加名为filename的文件的变化<br>git add . # 添加当前目录下及其子目录下的所有文件的变化<br></code></pre></td></tr></table></figure><p>添加文件到暂存区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cli">git commit -m &lt;version comment&gt; # 将当前版本提交，并添加注释`&lt;version comment&gt;`<br></code></pre></td></tr></table></figure><p>提交暂存区到仓库。</p>]]></content>
    
    
    <categories>
      
      <category>Cheatsheet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无监督句子多样性评价指标</title>
    <link href="/2022/11/28/NLP_sentence_diversity_evaluation/"/>
    <url>/2022/11/28/NLP_sentence_diversity_evaluation/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在项目推进过程中，产生了对生成句子多样性进行评价、筛选的需求。遂调研了部分现有的无监督句子多样性的评价指标，以备参考使用。 <span id="more"></span></p></blockquote><h2 id="bertscore">BERTScore</h2><p>paper: <a href="https://arxiv.org/abs/1904.09675v3">BERTSCORE: EVALUATING TEXT GENERATION WITH BERT</a></p><p><img src="/img/nlp_sentence_diversity/bertscore.png" /></p><p>每个词找另一个句子中和它内积最大的词</p><p><span class="math display">\[R_{BERT} = \frac{1}{|x|} \underset{x_i \in x}{\Sigma} \underset{\hat{x}\in \hat{x}} {max}  x_i^{T} \hat{x_j},\quadP_{BERT} = \frac{1}{\|\hat{x}\|} \underset{\hat{x_i} \in \hat{x}}{\Sigma} \underset{\hat{x} \in \hat{x}}{max} x_i^{T} \hat{x_j}, \quadF_{BERT} = 2\frac{P_{BERT}\cdot R_{BERT}}{P_{BERT} + R_{BERT}}\]</span></p><h4 id="importance-weighting">Importance Weighting</h4><p>based on inverse document frequency</p><p><span class="math display">\[idf(w) = -\log \frac{1}{M} \Sigma_{i=1}^{M} I [w \in x^{(i)}]\]</span></p><h4 id="rescaling">rescaling</h4><p><span class="math display">\[\hat{R}_{BERT} = \frac{R_{BERT} - b}{1-b}\]</span></p><p>b: empirical lower bound, calculated using Common Crawl monolingual datasets</p><h4 id="comparison">Comparison</h4><p>machine translation evalution -&gt; <span class="math inline">\(F_{BERT}\)</span></p><p>text generation in Eglish -&gt; 24-layer <span class="math inline">\(RoBERTa_{large}\)</span></p><p>non-English language -&gt; <span class="math inline">\(BERT_{multi}\)</span></p><h2 id="bleurt">BLEURT</h2><p>paper: <a href="https://arxiv.org/abs/2004.04696">BLEURT: Learning Robust Metrics for Text Generation. ACL 2020</a></p><h4 id="architecture">Architecture</h4><p>Bert + Linear Head</p><h4 id="pre-training-scheme">pre-training scheme</h4><p>random perturbations of Wikipedia sentences augmented with a diverse set of lexical and semantic-level supervision signals</p><ul><li>mask-filling with BERT -&gt; lexical alterations</li><li>backtranslation</li><li>randomly dropping out words -&gt; to recognize void preditions and sentence truncation in NLG systems</li></ul><p>pretraining metrics: weighted sum of previous metrics</p><h3 id="bartscore">BARTScore</h3><p>paper: <a href="https://arxiv.org/abs/2106.11520">BARTSCORE: Evaluating Generated Text as Text Generation</a></p><p>ExplainaBoard：http://explainaboard.nlpedia.ai/leaderboard/task-meval/</p><figure><img src="/img/nlp_sentence_diversity/bart_board.png" alt="image-20221128102518705" /><figcaption aria-hidden="true">image-20221128102518705</figcaption></figure><h4 id="evaluation-perspectives">evaluation perspectives:</h4><ul><li>Informativeness</li><li>Relevance</li><li>Fluency</li><li>Coherence</li><li>FActuality</li><li>Semantic Coverage</li><li>Adequacy</li></ul><h4 id="bartscore-1">BARTScore</h4><p><span class="math display">\[BARTSCORE = \Sigma_{t=1}^{m} \omega_t \log p(y_t | y_{&lt;t}, x, \theta)\]</span></p><p>using prompt to augment metrics</p><p>没太看明白，一开始列了一堆指标，最后又只有一个BARTScore。看了眼ExplainaBoard，猜测可能是评判的任务/输入数据对<span class="math inline">\(\{x,y\}\)</span>不同，BARTScore体现出的评判句子的方面就不一样</p><h2 id="moverscore">MoverScore</h2><p>MoverScore: Text Generation Evaluating with Contextualized Embeddings and Earth Mover Distance. <a href="https://arxiv.org/abs/1909.02622">link</a></p><h4 id="moverdistance">MoverDistance</h4><p><span class="math display">\[WMD(x^n, y^n) := \underset{F \in R^{|x^n| \times |y^n|}}{min} &lt;C,F&gt;,\quad s.t. F1 = f_{x^n}, F^T 1 = f_{y^n}\]</span></p><p><span class="math inline">\(C_{ij} = d(x_i^n, y_j^n)\)</span>, the distance between the i-th n-gram of x and the j-th n-gram of y</p><p><span class="math inline">\(F\)</span>: transportation flow matrix, <span class="math inline">\(F_{ij}\)</span> denoting the amount of flow traveling from the ith n-gram <span class="math inline">\(x_i^n\)</span> in <span class="math inline">\(x^n\)</span> to the j-th n-gram <span class="math inline">\(y_j^n\)</span> in <span class="math inline">\(y^n\)</span>.</p><p><span class="math inline">\(&lt;C,F&gt; = sum(C \odot F)\)</span></p><p><span class="math inline">\(d(x_i^n, y_j^n)\)</span> Euclidean distance</p><p><span class="math inline">\(f_{x^n_i} = \frac{1}{Z} \Sigma_{k=i}^{i+n-1} idf(x_k)\)</span></p><h4 id="vs-bertscore">vs BERTScore</h4><figure><img src="/img/nlp_sentence_diversity/bartscore_vs_bertscore.png" alt="image-20221128093223272" /><figcaption aria-hidden="true">image-20221128093223272</figcaption></figure><p>对于某个词，BERTScore算原句子中与它最相似的词的相似度（内积），而MoverScore算这个词和所有其他词的加权内积和，权重（即公式中的<span class="math inline">\(F\)</span>）通过idx算</p><h2 id="embedding-average">Embedding Average</h2><p>直接计算生成文本和参考文本中词向量的平均值作为文本的向量表示，然后计算两个文本的余弦相似度作为生成文本和参考文本的相似度：</p><p><span class="math display">\[\bar{e_r} = \frac{\Sigma_{\omega \in r} e_{\omega}}{| \Sigma_{\omega &#39; \in r} e_{\omega &#39;}|}\]</span> <span class="math display">\[EA := cos(\bar{e_r}, \bar{e_{\hat{r}}})\]</span></p><h2 id="perplexity">Perplexity</h2><h2 id="p.s.">p.s.</h2><p>很多现有的评价生成的文本的指标是基于Machine Translation任务的，计算原句子和翻译句子的相似度/匹配度。</p><h5 id="评价句子相似度的一些指标">评价句子相似度的一些指标</h5><ul><li><a href="https://aclanthology.org/S17-2001/">Semantic Textual Similarity</a></li><li><a href="https://aclanthology.org/W17-4767/">MEANT 2.0</a></li><li><a href="https://arxiv.org/abs/2109.06379">Compression, Transduction, and Creation: A Unified Framework for Evaluating Natural Language Generation</a></li><li>…</li></ul>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
      <category>NLP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>A Simple Compiler</title>
    <link href="/2022/11/07/A-Simple-Compiler/"/>
    <url>/2022/11/07/A-Simple-Compiler/</url>
    
    <content type="html"><![CDATA[<p>一个 Java 实现的 TXT 语言编译器, 目标平台为 RISC-V 32 (指令集 RV32M)。编译器大致分为词法分析、语法分析、语义分析及中间代码生成、目标代码生成四个部分。</p><span id="more"></span><h3 id="源语言的示例代码">源语言的示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> result;<br><span class="hljs-type">int</span> a;<br><span class="hljs-type">int</span> b;<br><span class="hljs-type">int</span> c;<br>a = <span class="hljs-number">8</span>;<br>b = <span class="hljs-number">5</span>;<br>c = <span class="hljs-number">3</span> - a;<br>result = a * b - ( <span class="hljs-number">3</span> + b ) * ( c - a );<br><span class="hljs-keyword">return</span> result;<br></code></pre></td></tr></table></figure><h2 id="词法分析">词法分析</h2><h3 id="编码表">编码表</h3><table><thead><tr class="header"><th>类别</th><th>正则表达式</th></tr></thead><tbody><tr class="odd"><td>return</td><td>return</td></tr><tr class="even"><td>=</td><td>=</td></tr><tr class="odd"><td>,</td><td>,</td></tr><tr class="even"><td>Semicolon</td><td>;</td></tr><tr class="odd"><td>+</td><td>+</td></tr><tr class="even"><td>-</td><td>-</td></tr><tr class="odd"><td>*</td><td>*</td></tr><tr class="even"><td>/</td><td>/</td></tr><tr class="odd"><td>(</td><td>(</td></tr><tr class="even"><td>)</td><td>)</td></tr><tr class="odd"><td>id</td><td>[a-zA-Z_][a-zA-Z]*</td></tr><tr class="even"><td>IntConst</td><td>[0-9]+</td></tr></tbody></table><h3 id="正则文法">正则文法</h3><p><span class="math inline">\(G=(V,T,P,S)\)</span>，其中<span class="math inline">\(V=\{S, A, B, C, 0,1,2,…,9, char\}\)</span>,<span class="math inline">\(T=\{任意符号\}\)</span>，<span class="math inline">\(P\)</span>定义如下</p><p>约定： <span class="math inline">\([s-t]\)</span>表示从s到t的所有ASCII字符中的一个</p><p>标识符：<span class="math inline">\(S \rightarrow [a-z] A,\)</span> <span class="math inline">\(A \rightarrow [a-z] A | [0-9] A | ϵ\)</span></p><p>整常数：<span class="math inline">\(S \rightarrow [1-9] B,\)</span> <span class="math inline">\(B \rightarrow [0-9] B | ϵ\)</span></p><p>运算符：<span class="math inline">\(S \rightarrow C,\)</span> <span class="math inline">\(C \rightarrow = | * | + | - | /\)</span></p><p>分隔符：<span class="math inline">\(S \rightarrow D,\)</span> <span class="math inline">\(D \rightarrow ; | ( | ) | ,\)</span></p><h3 id="状态转换图">状态转换图</h3><figure><img src="/img/A-Simple-Compiler/状态转换图.png" alt="状态转换图" /><figcaption aria-hidden="true">状态转换图</figcaption></figure><h3 id="流程">流程</h3><p>使用列表存储每个识别出的语法单元，读入输入代码，从前往后逐个读取字符，若遇到空格等其他空白字符跳过，否则，按照状态转换图识别语法单元，将其加入token列表中。若此语法单元为单词，且不是标识符，且不在符号表中，则其为新识别出的变量，将其添加到符号表中。</p><h2 id="语法分析">语法分析</h2><h3 id="状态栈和符号栈的数据结构">状态栈和符号栈的数据结构</h3><p>使用Stack类作为状态栈和符号栈的数据结构，状态栈的元素的基类为Status类，符号栈的基类为Token类（后续发现实际分析过程中不需要用到符号栈）。通过peek()函数获取栈顶元素，通过push()函数向栈中压入元素，通过pop()函数弹出栈顶元素，通过empty()函数判断栈是否为空。</p><h3 id="流程-1">流程</h3><ol type="1"><li>向状态栈中压入初始状态，向符号栈中压入符号“$”。</li><li>依次遍历输入串中的字符，根据当前状态栈栈顶的状态，判断此时应执行的Action。</li><li>若执行的动作为移进，则根据LR1分析表获取要转移到的状态（程序中存储在action对应的Status对象中），将状态压入状态栈，将字符压入符号栈,并调用移入时对应的观察者的函数（callWhenInShift函数）,通知观察者当前读到的字符和要转移到的状态。</li><li>若执行的动作为规约，则根据LR1分析表获取要规约的产生式（程序中存储在action对象的production属性中），调用规约时对应的观察者的函数（callWhenInReduce函数），通知观察者当前读到的字符和要用于规约的产生式，ProductionCollector观察者会将所有规约的产生式依次存储在列表中；获取产生式的头和体，将产生式的体对应的符号数从状态栈和符号栈中弹出，并将产生式的头压入符号栈。根据当前状态和状态站顶部状态查找LR1表，判断此时需要压入状态栈顶部的状态，并将其压入。</li><li>若执行的动作为接受，则调用处于接受状态时对应的观察者的函数（callWhenInAccept）通知各个观察者，语法分析结束。</li><li>重复执行2-5步，直到读完代码中的所有字符，或状态栈为空，或产生错误。</li></ol><h2 id="语义分析和中间代码生成">语义分析和中间代码生成</h2><h3 id="翻译方案">翻译方案</h3><p><span class="math display">\[ S \rightarrow D \  id; \{ id.type = D.type \} \]</span></p><p><span class="math display">\[ D \rightarrow int ; \{ int.type = INT, D.type = int.type \} \]</span></p><p>其余产生式规约式不执行任何动作</p><h3 id="使用的数据结构">使用的数据结构</h3><p><strong>语义分析：</strong>使用基类位SourceCodeType的栈（Stack）作为类型栈typeStack的数据结构，存储当前符号栈内对应符号的类型（type）；使用基类为Token的栈（Stack）作为符号栈tokenStack的数据结构，存储移进的单词（token）</p><p><strong>中间代码生成：</strong>使用基类为Instruction的列表(List)instructions作为中间代码存储的数据结构，依次存储生成的中间代码，使用基类为IRValue的栈（Stack）作为符号栈irValueStack的数据结构，存储符号栈对应的ir表达式的值。</p><h3 id="流程-2">流程</h3><ol type="1"><li>当动作为接受时，不执行任何操作。</li><li>当动作为移进时，将对应的符号压入符号栈。如果此符号为关键字int，则将INT压入类型栈，否则将null压入类型栈。</li><li>当动作为规约时，首先判断要执行规约的产生式编号，若编号为4，则跳到第4步，若编号为5，则跳到第5步，否则，调到第6步.</li><li>此时待规约的产生式为 <span class="math inline">\(S \rightarrow D \ id;\)</span>。分别弹出并获取符号栈和类型栈顶端的两个元素，并设置为符号栈第一个元素（id）在符号表中的类型为类型栈从上往下第二个元素的类型（D对应的类型）。并向符号栈和类型栈中压入null（对应左部的S）。</li><li>此时待规约的产生式为 <span class="math inline">\(D \rightarrow \ int ;\)</span> 弹出符号栈和类型栈栈顶的元素，将类型栈栈顶元素的类型作为左部符号的类型，再压入符号栈，向符号栈中压入null(对应左部的D)。</li><li>此时待规约的产生式没有特殊的翻译动作，只需从符号栈和类型栈中弹出与产生式右部元素个数一致的元素，并压入null作为左部对应的符号/类型。</li></ol><h2 id="目标代码生成">目标代码生成</h2><h3 id="对中间代码进行预处理">对中间代码进行预处理</h3><ol type="1"><li>将操作两个立即数的 BinaryOp 直接进行求值得到结果, 然后替换成 MOV 指令。</li><li>将操作一个立即数的指令 (除了乘法和左立即数减法) 进行调整, 使之满足 a := b op imm 的格式。</li><li>将操作一个立即数的乘法和左立即数减法调整, 前插一条 MOV a, imm, 用 a 替换原立即数, 将指令调整为无立即数指令.</li><li>舍弃Ret指令之后的所有指令</li></ol><h3 id="识别各变量最后一次使用的位置">识别各变量最后一次使用的位置</h3><p>从后往前遍历预处理后的中间代码序列。用列表存储当前已经遍历到过的变量。每处理一条指令，分别判断它的两个原操作数中是否为立即数，若不是，再查看此变量是否被遍历到过。若此变量从未被遍历到过，说明此变量最后一次出现的位置便为这条指令，将此信息存入列表中保存。</p><p>在遍历过程中，若变量出现在指令的目标操作数位置，且不出现在源操作数中，说明此指令前此变量的值与后续执行过程无关，将此变量从存储但钱已经遍历到过的变量列表中删去。</p><h3 id="将中间代码转化为目标代码">将中间代码转化为目标代码</h3><p>创建AsmInstruction类，表示riscv形式的汇编代码类，创建AsmInstructionKind枚举类，表示riscv代码的各种类型。</p><p>创建RegisterAssigner类，用于分配和回收空闲的寄存器。其中，通过列表维护空闲寄存器，利用双射Map维护变量和已利用的寄存器之间的双射关系。当请求分配寄存器时，从空闲寄存器列表随机分配一个寄存器，并将其添加到双射Map中。当回收某一寄存器时，将其从双射Map中删除，并将相应寄存器重新存放回空闲寄存器列表。 遍历处理后的中间代码，提取每条指令的左右操作数，将其转化为相应的AsmInstruction对象，并存放到列表中。</p><p>根据维护的变量最后一次出现的位置信息，若当前指令为变量最后一次出现的指令，则将相应变量对应的寄存器释放。</p>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Compiler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Housing Price estimator</title>
    <link href="/2022/10/30/Housing-Price-estimator/"/>
    <url>/2022/10/30/Housing-Price-estimator/</url>
    
    <content type="html"><![CDATA[<p>本项目旨在通过房屋交易市场交易记录，挖掘数据间潜在的关联关系，设计高效、解释性强、鲁棒的算法对房屋交易价格进行预测。</p><span id="more"></span><h3 id="可视化工具">可视化工具</h3><ul><li>sweetviz: Python开源库，快速可视化目标值和比较数据集。</li><li>shap: SHapley Additive exPlanation，解释模型输出。</li></ul><h3 id="基本内容">基本内容</h3><h4 id="数据分析">数据分析</h4><p>房屋交易市场交易记录中，包括数值型属性，文字属性，时间属性等。其中数值型属性包括连续值、离散值、缺失值等。文字型属性包括级别、地址、街区等。</p><p>先使用pandas、matplotlib、seaborn，sweetviz等库函数可视化数据，挖掘数据之间的潜在的关系，并去除相关性较小的特征。</p><figure><img src="\img\Housing-Price-estimator\数据清洗前特征之间的相关关系.png" alt="数据清洗前特征之间的相关关系" /><figcaption aria-hidden="true">数据清洗前特征之间的相关关系</figcaption></figure><h4 id="数据预处理">数据预处理</h4><p>对选取的特征中的值进行预处理：填充缺失值，将文字属性数值化，识别并处理异常值等。</p><p>用众数填充总单元、居住单元、邮编、修建年份、公寓号中的缺失值。按居住单元分组，用均值填充总平方英尺中的缺失值。用0填充出售价格中的缺失值。</p><p>去除训练集中出售价格为0的数据。根据图像显示的数据间的关系，以及数据间的相关系数，发现商业单元、土地平方英尺、地役权、出售日期这四个特征与目标出售价格之间的相关性很低，遂将其删除。用均值填充所有含nan的数值列。</p><p>对所有特征进行归一化，并使用主成分分析方法，分析每个特征对总体的贡献。</p><p>数据清洗后特征之间的相关关系如下图所示。</p><figure><img src="\img\Housing-Price-estimator\数据清洗后特征之间的相关关系.png" alt="数据清洗后特征之间的相关关系" /><figcaption aria-hidden="true">数据清洗后特征之间的相关关系</figcaption></figure><h4 id="模型选择">模型选择</h4><p>首先在普通的LinearRegression线性回归模型上进行预测，再引入带惩罚项函数的模型，如Ridge,Lasso等，进一步采用RandomForest，比较不同模型的回归结果，选择最优模型。</p><h4 id="模型验证">模型验证</h4><p>随机选取原训练集的20%作为验证集，剩下的80%作为训练集。使用训练集对模型进行训练，预测验证集的结果，与实际结果比较，计算损失(均方误差)，评判模型的效果。</p><figure><img src="\img\Housing-Price-estimator\shap可视化各特征对最终结果的影响.png" alt="shap可视化各特征对最终结果的影响" /><figcaption aria-hidden="true">shap可视化各特征对最终结果的影响</figcaption></figure><h3 id="结果分析">结果分析</h3><p>初始时，将所有特征按照常识进行预处理，所得预测结果较差。进一步分析发现处理后的数据与最终结果之间的相关性均较小，最大不超过0.5，而普遍小于0.1。此后利用图像分析各个特征之间的相关性，发现总平方英寸这一特征与目标之间的相关性最高，于是先从此特征入手。利用此单一特征进行回归预测，在测试集上的均方误差为7749025.804。</p><p>此后，加入其他特征，并分组填充缺失值，提高数据质量，使用主成分分析等方法分析特征的重要性，并选取几个比较显著的特征，在测试集上的均方误差为7224550.11</p><figure><img src="\img\Housing-Price-estimator\主成分分析各特征的解释方差和累计解释占比.png" alt="主成分分析各特征的解释方差和累计解释占比" /><figcaption aria-hidden="true">主成分分析各特征的解释方差和累计解释占比</figcaption></figure><figure><img src="\img\Housing-Price-estimator\算法性能曲线图.png" alt="算法性能曲线图" /><figcaption aria-hidden="true">算法性能曲线图</figcaption></figure><p>由于此数据集较为复杂，特征之间的相关性较低，难以在任务上得到比较理想的结果，预测价格与实际价格的相关系数最高不超过50%。如果需要更为准测的预测，可能需要更多高质量的相关性较高的数据。</p>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NSCSCC2022 龙芯杯参赛总结</title>
    <link href="/2022/09/03/%E9%BE%99%E8%8A%AF%E6%9D%AF%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/09/03/%E9%BE%99%E8%8A%AF%E6%9D%AF%E5%8F%82%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="note note-info">            <p>我参加的是2022年龙芯杯个人赛，从2022年2月左右开始准备，到2022年8月完赛。以下为我的参赛历程与感想。</p>          </div><span id="more"></span><h3 id="赛事简介">赛事简介</h3><p>全称 ： “龙芯杯”全国大学生计算机系统能力培养大赛</p><p>全国大学生计算机系统能力大赛（National Student Computer System Capability Challenge, NSCSCC）是由教育部高等学校计算机类专业教学指导委员会和系统能力培养研究专家组共同发起，以学科竞赛推动专业建设和计算机领域创新人才培养体系改革、培育我国高端芯片及核心系统的技术突破与产业化后备人才为目标,面向高校大学生举办的全国性大赛。</p><p>大赛共分3个赛道：CPU、编译系统、操作系统。其中，CPU赛道即“龙芯杯”竞赛。</p><p>“龙芯杯”竞赛分3个赛道：MIPS团队赛、MIPS个人赛 和 LoongArch挑战赛。</p><ul><li><p>MIPS团队赛 ： 开发支持32位MIPS基准指令集的简易计算机系统。加分项：运行操作系统、实现加速器、设计可演示的应用</p></li><li><p>MIPS个人赛 ： 开发支持32位MIPS基准指令集的简易计算机系统。完成三级功能测试（最多22条指令），支持SRAM、UART，运行监控程序。 总成绩 = 功能测试 得分 + 性能测试 得分</p></li><li><p>LoongArch挑战赛 ： 开发支持LoongArch32 Reduced指令集的简易计算机系统，并在自己编写的CPU上启动Linux操作系统。 总成绩 = 70% * benchmark基准测试成绩 + 30% * 系统展示及答辩</p></li></ul><p>*详细内容可参考<a href="https://github.com/loongson-education/nscscc-wiki">龙芯官方wiki</a></p><h3 id="个人赛要做什么">个人赛要做什么？</h3><ul><li>一个支持MIPS基准指令集的MIPS位系统</li><li>使用实验板上的SRAM作为存储</li><li>CPU核能够通过接口与各I/O设备互联通信</li><li>支持MIPS-C3指令集（总共39条指令左右），运行提供的MIPS监控程序</li><li>决赛：使用汇编语言现场写算法题，编译后放到自己做的CPU上跑</li><li>......</li></ul><h3 id="前期准备">前期准备</h3><p>2022NSCSCC的时间线如下，仅供参考。 <img src="/img/龙芯杯参赛总结/2022timeline.png" /></p><div class="note note-secondary">            <p>我们学校组织备赛开始得较早，在2021年12月底即组织了宣讲和预报名，年后即开始了每周进度汇报会。虽然前期的进度不算快，但每周前进一小步，还是积累了不少东西</p>          </div><p>理论部分，首先阅读《计算机组成与设计》学习设计相关的理论知识，之后跟着雷思磊的《自己动手写cpu》实现一个支持基本的mips指令的cpu。我一开始把书上写的都实现了一遍，之后再看着官方要求的指令把不相关的删掉了，实际上可以只实现需要的部分。</p><p>具体针对比赛所需，我阅读了龙芯官方发的前几届参赛选手的经验指南，但很多写得很长，讲了很多专业术语，最开始看的时候晕头转向的。后来还是先根据官方的技术指南，先明确需求，需要实现什么，再针对性得根据这些看还需要实现什么，在哪些部分可以提高性能。</p><h3 id="架构与技术概要">架构与技术概要</h3><p>系统总体架构采取顺序单发射五级流水cpu，支持延迟槽。支持uart串口通信，支持sram，其中访存只占据一个周期。较短的访存时间对很大程度上限制了cpu的频率。最后最高可以跑到63.34M。</p><figure><img src="/img/龙芯杯参赛总结/cpu整体架构.png" alt="cpu总体架构" /><figcaption aria-hidden="true">cpu总体架构</figcaption></figure><p>cpu 核心采用顺序单发射五级流水线，各流水线模块关系如下图所示。</p><figure><img src="/img/龙芯杯参赛总结/cpu核心架构.png" alt="cpu核心架构" /><figcaption aria-hidden="true">cpu核心架构</figcaption></figure><h3 id="参赛作品亮点">参赛作品亮点</h3><p>采用wallace tree实现两周期乘法器，大大减少了乘法模块的资源消耗，并减少了因dsp乘法连线过长导致的关键路径。</p><p>单周期访问sram，在频率较低时极大得减少了因访存而导致的流水线停顿，大大提高了系统的ipc。 值得一提的是，在优化阶段我曾尝试多周期访存+cache，但仔细分析后发现，这种配置下如果要达到和单周期五级流水相似的性能，需要至少110+M的频率，且多周期访存产生的停顿意味着需要改变延迟槽判断的方式等等一系列细节逻辑，且80+M时就会因数据前递的较长连线而产生关键路径。最后权衡系统性能，系统复杂度（稳定度），以及时间分配（练习汇编算法），还是采用了顺序五级流水的基础结构。</p><p>系统运行流畅，停顿概率很低，仅在乘法后RAW-1，访存取指同时访问imem两种情况下才会停顿。</p><h3 id="作品最终完成度">作品最终完成度</h3><p>比赛要求任务全部完成，实现了MIPS C3指令集总共39条指令，支持uart串口通信，sram访存。性能测试结果为: STREAM用时0.099s, MATRIX用时0.141s, CRYPTONIGHT用时0.364s, 总计0.604s。决赛时在规定时间内完成了二分查找的汇编算法，并在自己设计的cpu上跑通。</p><h3 id="备赛经验及建议">备赛经验及建议</h3><p><strong>备赛前期：</strong>阅读《计算机组成与设计》，《计算机体系结构：量化研究方法》两本经典书籍学习所需的基本原理。阅读《自己动手写cpu》，并上手写代码，实现一个基本版的cpu。</p><p><strong>备赛冲刺阶段：</strong>可以在初赛前一个半月左右着手开始优化系统，不建议把战线拉太长，不然中间阶段不知道做什么/迷失方向没人讨论的时候会很痛苦。优化前先仔细调研优化方法，及其在比赛任务上的优化效率。可以参考GitHub上之前参赛选手开源出的作品代码作为参考。不用各种优化方法兼顾，重点攻克对于评分任务提升较大，稳定性较高的方案。</p><p><strong>备赛后期：</strong>初赛结束后还有两周左右的时间到决赛，不建议再修改cpu设计，因为时间很匆忙，不一定赶得出来一个稳定版，而且决赛任务不仅仅看重cpu性能。建议放松一两天后着力准备决赛的编程任务。决赛编程任务属于中等难度的算法题，但需要用汇编实现。参考准备路线：跟着<a href="https://github.com/changgyhub/leetcode_101">LeetCode 101</a> 这本算法书练习经典算法。 到c++容器那章前基本就够了，练习的编程语言任意，顺手就好，用高级语言就行，方便在leetcode上在线评测。之后可以再看看University of Alberta 的CMPUT229这门课的<a href="https://github.com/cmput229/MIPSPatterns">MIPS汇编教程</a> , 掌握高级语言流程结构和汇编语言转换的基本方法，用MIPS汇编实现几个经典的算法，如快排，二分等等，并在Mars和自己的cpu上依次验证。</p><p><strong>决赛技巧：</strong>个人赛决赛仍然采用线上测评平台，由于比赛时间有限，同时在线人数较多，决赛时线上编译速度很慢，工程文件改动后重新编译至少需要20-30min，运行测试也需要排队5min左右。但仅仅修改汇编代码只会重新编译汇编代码，工程文件不再重新编译，只需1分钟左右就可在gitlab上编译完成，。因此强烈建议在决赛时不要修改内核，节省时间。同时，可以在决赛前在多个git分支上准备好多个不同频率的工程版本（比如60M稳定版用于测试汇编代码正确性，频率再高的版本用来降低时间刷分），汇编程序写好后可以分别写到这些分支上，就可以在短时间内得到多个在线编译通过的不同频率的提交文件，能够高效刷分测试。（我决赛时只准备了稳定版本的，后面时间比较紧张就没有再提高频率，有点遗憾。）</p><p>最后，十分感谢老师们给我们提供的良好的交流机会，督促我们不断优化性能，为我们提供了优越的备赛交流环境。也非常感谢一同参加比赛的各位大佬十分耐心回答我的问题以及在交流碰撞出的新思路！</p>]]></content>
    
    
    <categories>
      
      <category>Projects</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NSCSCC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
